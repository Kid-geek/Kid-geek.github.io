<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[HttpClient基本使用]]></title>
      <url>http://yoursite.com/2017/08/07/HttpClient%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>做了一个月爬虫了,从头整理下吧,方便以后查询使用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import org.apache.http.client.methods.CloseableHttpResponse;</div><div class="line">import org.apache.http.client.methods.HttpGet;</div><div class="line">import org.apache.http.impl.client.CloseableHttpClient;</div><div class="line">import org.apache.http.impl.client.HttpClients;</div><div class="line"></div><div class="line">public class HttpClientDemo &#123;</div><div class="line">	public static void main(String[] args) throws Exception &#123;</div><div class="line">		// 创建默认的客户端实例</div><div class="line">		CloseableHttpClient httpClient = HttpClients.createDefault();</div><div class="line"></div><div class="line">		// 创建get请求实例</div><div class="line">		HttpGet httpget = new HttpGet(&quot;http://www.baidu.com&quot;);</div><div class="line"></div><div class="line">		System.out.println(&quot;executing request &quot; + httpget.getURI());</div><div class="line">		try &#123;</div><div class="line">			// 客户端执行get请求 返回响应</div><div class="line">			CloseableHttpResponse response = httpClient.execute(httpget);</div><div class="line"></div><div class="line">			// 服务器响应状态行</div><div class="line">			System.out.println(response.getStatusLine().toString());</div><div class="line"></div><div class="line"></div><div class="line">		&#125; finally &#123;</div><div class="line">			httpClient.close();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单理解下:<br><code>CloseableHttpClient httpClient = HttpClients.createDefault();</code></p>
<p>上述代码我们可以理解为我先打开了一个“浏览器”，注意，并不是真正意义上的浏览器，只是进行了这步操作，表明我们马上就可以访问网页了。</p>
<p><code>HttpGet httpget = new HttpGet(&quot;http://www.baidu.com&quot;);</code></p>
<p>上述代码就表示了我们请求了一个页面，用的是get方法，对于请求页面使用的是哪一种方法，一般来说，只有在进行登录页面的时，我们会使用Post方法。我们可以通过chrome开发者工具来了解对于这个页面是使用了哪个方法。</p>
<p>我们理解为上面两个步骤就是打开一个浏览器，然后在地址栏输入了一个网址。</p>
<p><code>CloseableHttpResponse response = httpClient.execute(httpget);</code><br>上述代码相当于我们此时在浏览器中按下了回车，URL资源所在的服务器就会开始给你返回这个网页的数据。包括请求头，消息实体等等.最后在finally释放资源.</p>
<p><a href="http://hc.apache.org/downloads.cgi" target="_blank" rel="external">HttpClient jar下载</a><br>参考自:<a href="http://www.cnblogs.com/icedream61/p/4887250.html" target="_blank" rel="external">Hg_Yi</a></p>
]]></content>
      
        <categories>
            
            <category> Java爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[消愁]]></title>
      <url>http://yoursite.com/2017/08/03/%E6%B6%88%E6%84%81/</url>
      <content type="html"><![CDATA[<p><img src="/images/xiaochou.png" alt="“消愁”"></p>
<p><center> 当你走进这欢乐场<br>背上所有的梦与想<br>各色的脸上各色的妆<br>没人记得你的模样<br>三巡酒过你在角落<br>固执的唱着苦涩的歌<br>听他在喧嚣里被淹没<br>你拿起酒杯对自己说<br><strong>一杯敬朝阳，一杯敬月光</strong><br>唤醒我的向往，温柔了寒窗<br>于是可以不回头的逆风飞翔<br>不怕心头有雨，眼底有霜<br><strong>一杯敬故乡，一杯敬远方</strong><br>守着我的善良，催着我成长<br>所以南北的路从此不再漫长<br>灵魂不再无处安放<br><strong>一杯敬明天，一杯敬过往</strong><br>支撑我的身体，厚重了肩膀<br>虽然从不相信所谓山高水长<br>人生苦短何必念念不忘<br><strong>一杯敬自由，一杯敬死亡</strong><br>宽恕我的平凡，驱散了迷惘<br>好吧天亮之后总是潦草离场<br>清醒的人最荒唐<br>好吧天亮之后总是潦草离场<br>清醒的人最荒唐<br>—— 毛不易<br><a href="https://i.y.qq.com/v8/playsong.html?songid=203451421&amp;source=yqq#wechat_redirect" target="_blank" rel="external">消愁-QQ音乐</a></center></p>
<p></p>
]]></content>
      
        <categories>
            
            <category> 碎碎念 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[碎碎念]]></title>
      <url>http://yoursite.com/2017/07/29/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>广厦万间,夜眠八尺.<br>珍馐百味,不过一饱.</p>
]]></content>
      
        <categories>
            
            <category> 碎碎念 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git从零开始]]></title>
      <url>http://yoursite.com/2017/07/26/Git%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p><code>从头整理下Git流程</code></p>
</blockquote>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>安装Git后,创建仓库目录文件夹,打开命令行输入<code>ssh-keygen -t rsa -C &quot;邮箱名&quot;</code> 创建SSH密钥。</li>
<li>在GitHub账号设置中添加SSH许可。</li>
<li><code>ssh -T git@github.com</code>连接GitHub</li>
<li>修改个人信息  <code>git config --global user.name &quot;名字&quot;</code>  <code>git config --global user.email &quot;邮箱&quot;</code><a id="more"></a>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2></li>
<li><code>git init</code>  初始化本地仓库</li>
<li><code>git clone url</code>  下载远程Github仓库,url为github clone链接</li>
<li>基本操作:  <ul>
<li><code>git add file_name</code> 将文件添加到缓存.  <code>*</code>为全部文件</li>
<li><code>git status</code> 查看项目当前状态  <code>git status -s</code>获得简短输出</li>
<li><code>git diff</code>查看已写入缓存与已修改但尚未写入缓存的改动的区别. 例如修改了文件里的内容后,<code>git status</code> 显示你上次提交更新后的更改或者写入缓存的改动， 而 <code>git diff</code> 一行一行地显示这些改动具体是啥。</li>
<li><code>git commit</code>将缓存区内容添加到仓库中.<code>git commit -m &quot;注释&quot;</code>可以简单说明改动.</li>
<li><code>git rm file</code>将条目从缓存区删除,包括文件本身.如果要在工作目录中保留文件用 <code>git rm --cached</code> </li>
<li><code>git mv</code> 命令用于移动或重命名一个文件、目录、软连接。</li>
</ul>
</li>
<li>分支管理:  <ul>
<li><code>git branch (branchname)</code>创建一个新的分支</li>
<li><code>git checkout</code> 切换分支,在切换分支时会用该分支最后提交的快照替换工作目录的内容,所以多个分支不需要多个目录.</li>
<li><code>git branch</code>列出本地分支,<code>*</code>为当前所在分支</li>
<li><code>git branch -d (branchname)</code>删除分支</li>
<li><code>git merge branchname</code>合并分支内容</li>
</ul>
</li>
<li>查看提交历史<ul>
<li><code>git log</code>查看历史信息,可以用<code>git log --oneline</code>查看简明信息</li>
</ul>
</li>
</ol>
<h2 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h2><ol>
<li>创建本地仓库目录文件夹</li>
<li>创建GitHub远程仓库,<code>git clone url</code>克隆到本地 </li>
<li><code>git init</code>                               # 初始化</li>
<li><code>git add README.md</code>                    # 添加文件</li>
<li><code>git commit -m &quot;添加注释信息&quot;</code>       # 提交并备注信息</li>
<li><code>git push</code>提交到远程仓库<br><br></li>
</ol>
<p><code>ps.只是最最最基础的流程,分支慢慢研究了.</code><br><br></p>
<p>##最后<br>会随着看的越来越多慢慢更新的,先熟悉下.<br>贴两个链接:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/icedream61/p/4887250.html" target="_blank" rel="external">简单命令加流程</a><br><a href="http://www.runoob.com/w3cnote/git-guide.html" target="_blank" rel="external">GitHub简明教程</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式-单例模式（饿汉模式or懒汉模式）]]></title>
      <url>http://yoursite.com/2017/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8For%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在从头研究项目的时候发现存储配置文件字段用到了饿汗单例模式，深入研究看看。</p>
</blockquote>
<p>##单例模式<br>单例模式就是在应用程序中只创建一个该类的对象。<br>这个设计模式主要目的是想在整个系统中只能出现一个类的实例。比如你的软件的<strong>全局配置信息</strong>，或者是一个Factory，或是一个主控类，等等。你希望这个类在整个系统中只能出现一个实例。当然，作为一个技术负责人的你，你当然有权利通过使用非技术的手段来达到你的目的。比如：你在团队内部明文规定，“XX类只能有一个全局实例，如果某人使用两次以上，那么该人将被处于2000元的罚款！”（呵呵），你当然有权这么做。但是如果你的设计的是东西是一个类库，或是一个需要提供给用户使用的API，恐怕你的这项规定将会失效。因为，你无权要求别人会那么做。所以，这就是为什么，我们希望通过使用技术的手段来达成这样一个目的的原因。<br><a id="more"></a></p>
<p>###饿汉模式和懒汉模式</p>
<blockquote>
<p>饿汉 类加载时候就已经完成了初始化，不需要同步<br>懒汉 类加载的时候不初始化，需要同步 </p>
</blockquote>
<p><strong>懒汉模式</strong>：类加载时不初始化，因此在类加载时速度快，但运行时获取对象的速度慢。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton singleton = null;  </div><div class="line">    private Singleton() &#123;  &#125;                    //私有的构造函数，表明这个类不可能形成实例。</div><div class="line">    public static Singleton getInstance() &#123;     //借助getInstance()让其形成实例。</div><div class="line">        if (singleton== null) &#123;</div><div class="line">            singleton= new Singleton();</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li>即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。</li>
<li>在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。</li>
<li>取实例时，只需要使用Singleton.getInstance()就行了。</li>
</ol>
<p><strong>饿汉模式</strong>：在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class EagerSingleton &#123;</div><div class="line"></div><div class="line">    private static EagerSingleton instance = new EagerSingleton();//静态私有成员，已初始化</div><div class="line">    </div><div class="line">    private EagerSingleton() </div><div class="line">    &#123;</div><div class="line">        //私有构造函数</div><div class="line">    &#125;</div><div class="line">    //静态，不用同步（类加载时已初始化，不会有多线程的问题）</div><div class="line">    public static EagerSingleton getInstance()    &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##单例模式的多线程<br>多线程：双重检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Singleton</div><div class="line">&#123;</div><div class="line">    private volatile static Singleton singleton = null;</div><div class="line">    private Singleton()  &#123;    &#125;</div><div class="line">    public static Singleton getInstance()   &#123;</div><div class="line">        if (singleton== null)  &#123;</div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                if (singleton== null)  &#123;</div><div class="line">                    singleton= new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>第一个条件判断实例是否已经创建,如果创建了则不需要同步,直接返回就好,否则开始同步线程.</li>
<li>第二个条件判断,如果被同步的线程中,有一个线程创建了对象,那么别的线程就不用再创建了.</li>
</ol>
<p><strong>注意:此处volatile的作用</strong></p>
<ol>
<li>这个变量不会在多个线程中存在复本，直接从内存读取。</li>
<li>这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。</li>
</ol>
<p>还有一种《Effective Java》推荐方式<code>静态内部类</code>的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">        private static final Singleton INSTANCE = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static final Singleton getInstance() &#123;  </div><div class="line">        return SingletonHolder.INSTANCE; </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<p>小结：<br>静态内部类还是不太懂，后续慢慢思考一下。</p>
<p>参考资料：<br>深入浅出单实例SINGLETON设计模式  <a href="http://coolshell.cn/articles/265.html" target="_blank" rel="external">http://coolshell.cn/articles/265.html</a><br>如何正确地写出单例模式         <a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="external">http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/</a>     </p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线程与进程简单理解]]></title>
      <url>http://yoursite.com/2017/05/09/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>由于线程和进程比较抽象，不好理解，看到篇文章，简单记录下，方便理解。</p>
<ol>
<li>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</li>
<li>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，<strong>单个CPU一次只能运行一个任务</strong>。<a id="more"></a></li>
<li>进程就像工厂的车间，它代表CPU所能处理的单个任务。车间可以有很多个，<strong>任一时刻，CPU总是运行一个进程，其他进程处于非运行状态</strong>。</li>
<li>一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人。一个进程可以包括多个线程。</li>
<li>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。<strong>这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</strong></li>
<li>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表<strong>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</strong></li>
<li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫<strong>“互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域</strong>。</li>
<li>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。<strong>这好比某些内存区域，只能供给固定数目的线程使用</strong>。</li>
<li>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做<strong>“信号量”（Semaphore），用来保证多个线程不会互相冲突。</strong><br>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，<strong>因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</strong></li>
</ol>
<p>总结：<br>操作系统的设计，因此可以归结为三点：<br>（1）以多进程形式，允许多个任务同时运行；<br>（2）以多线程形式，允许单个任务分成不同的部分运行；<br>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>
]]></content>
      
        <categories>
            
            <category> 底层机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 底层机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 中的序列化]]></title>
      <url>http://yoursite.com/2017/04/19/java%20%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="序列化是干什么的？"><a href="#序列化是干什么的？" class="headerlink" title="序列化是干什么的？"></a>序列化是干什么的？</h3><p> 简单说就是为了保存在内存中的各种对象的状态，并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存Object States，但是Java给你提供一种应该比你自己好的保存对象状态的机制,那就是序列化。</p>
<h3 id="什么情况下需要序列化"><a href="#什么情况下需要序列化" class="headerlink" title="什么情况下需要序列化"></a>什么情况下需要序列化</h3><p>1.当你想把的内存中的对象保存到一个文件中或者数据库中时候；<br>2.当你想用套接字在网络上传送对象的时候；<br>3.当你想通过RMI传输对象的时候；</p>
<a id="more"></a>
<h3 id="当对一个对象实现序列化时，究竟发生了什么？"><a href="#当对一个对象实现序列化时，究竟发生了什么？" class="headerlink" title="当对一个对象实现序列化时，究竟发生了什么？"></a>当对一个对象实现序列化时，究竟发生了什么？</h3><p>在没有序列化前，每个保存在堆（Heap）中的对象都有相应的状态（state），即实例变量（instance ariable）比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Foo myFoo = new Foo(); </div><div class="line">myFoo .setWidth(37); </div><div class="line">myFoo.setHeight(70);</div></pre></td></tr></table></figure></p>
<p> 当通过下面的代码序列化之后，MyFoo对象中的width和Height实例变量的值（37，70）都被保存到foo.ser文件中，这样以后又可以把它 从文件中读出来，重新在堆中创建原来的对象。当然保存时候不仅仅是保存对象的实例变量的值，JVM还要保存一些小量信息，比如类的类型等以便恢复原来的对象。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;);</div><div class="line">ObjectOutputStream os = new ObjectOutputStream(fs); </div><div class="line">os.writeObject(myFoo);</div></pre></td></tr></table></figure></p>
<h3 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.io.*; </div><div class="line"></div><div class="line">public class Box implements Serializable </div><div class="line">&#123; </div><div class="line">private int width; </div><div class="line">private int height; </div><div class="line"></div><div class="line">public void setWidth(int width)&#123; </div><div class="line">this.width = width; </div><div class="line">&#125; </div><div class="line"></div><div class="line">public void setHeight(int height)&#123; </div><div class="line">this.height = height; </div><div class="line">&#125; </div><div class="line"></div><div class="line">public static void main(String[] args)&#123; </div><div class="line">Box myBox = new Box(); </div><div class="line">myBox.setWidth(50); </div><div class="line">myBox.setHeight(30); </div><div class="line"></div><div class="line">try&#123; </div><div class="line">FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;); </div><div class="line">ObjectOutputStream os = new ObjectOutputStream(fs); </div><div class="line">os.writeObject(myBox); </div><div class="line">os.close(); </div><div class="line">&#125;catch(Exception ex)&#123; </div><div class="line">ex.printStackTrace(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a>相关注意事项</h3><p>1.当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；<br>2.当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；<br>3.并非所有的对象都可以序列化。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>就像你寄一箱饼干，因为体积太大，就全压成粉末紧紧地一包寄出去，这就是序列化的作用。<br>只不过JAVA的序列化是可以完全还原的。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[接口详解]]></title>
      <url>http://yoursite.com/2017/04/08/%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h1><hr>
<h3 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h3><p>类是一种具体实现体，而接口定义了一种规范，接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部状态数据，也不关心类里的实现细节，只规定了这批类里必须提供某些方法。</p>
<blockquote>
<p>可见，接口不提供任何实现方法。接口体现的是规范和实现分离的哲学。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="接口定义注意事项"><a href="#接口定义注意事项" class="headerlink" title="接口定义注意事项"></a>接口定义注意事项</h3><ul>
<li>接口可以有多个直接父接口，支持多继承，但接口只能继承接口，不能继承类。</li>
<li>接口里不能包含构造器和初始化块定义。接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法或默认方法）、内部类（包括内部接口、枚举）。</li>
<li>系统自动为接口里定义的成员变量增加<code>public static final</code>修饰符。</li>
</ul>
<hr>
<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><p>接口的主要用途：</p>
<ol>
<li>定义变量，也可用于强制类型转换。</li>
<li>调用接口中定义的常量</li>
<li>被其他类实现</li>
</ol>
<hr>
<h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>设计目的上的差别:<br>接口体现的是一种规范，是多个模块间的耦合标准。接口类似于整个系统的“总纲”，因此，接口不应该经常被改写。<br>抽象类则不一样，体现的是一种模板式设计。可以在后期更加完善。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[疯狂JAVA摘句]]></title>
      <url>http://yoursite.com/2017/03/20/%E7%96%AF%E7%8B%82JAVA%E6%91%98%E5%8F%A5/</url>
      <content type="html"><![CDATA[<p>真正优秀的程序员当然可以使用IDE工具，但真正的程序员，即使使用vi、记事本也一样可以完成非常优秀的项目。<br>正确对待IDE工具的态度是：可以使用IDE工具，但绝不可依赖IDE工具。<br>学习阶段，前期不要使用IDE工具；开发阶段，使用IDE工具。<br>真正技术掌握了，无论用什么IDE工具都得心应手。</p>
<blockquote>
<p>对于IDE工具，业内有一个说法：IDE工具会加快高手的开发效率，但会使初学者更白痴。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 摘句 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 摘句 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git命令实践]]></title>
      <url>http://yoursite.com/2017/03/19/Git%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h1 id="Git入门"><a href="#Git入门" class="headerlink" title="Git入门"></a>Git入门</h1><p>标签（空格分隔）： 基本操作</p>
<hr>
<h3 id="git-init-–-初始化仓库"><a href="#git-init-–-初始化仓库" class="headerlink" title="git init – 初始化仓库"></a>git init – 初始化仓库</h3><p>使用Git仓库管理必须先初始化仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir Git-first</div><div class="line">cd Git-first</div><div class="line">git init</div><div class="line">Initialized empty Git repository in /Volumes/CODE/Git-tutorial/.git/</div></pre></td></tr></table></figure></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="git-status-–-查看仓库状态"><a href="#git-status-–-查看仓库状态" class="headerlink" title="git status – 查看仓库状态"></a>git status – 查看仓库状态</h3><p>git status查看仓库状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$git status</div><div class="line">On branch master</div><div class="line"></div><div class="line">Initial commit</div><div class="line"></div><div class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</div></pre></td></tr></table></figure></p>
<p>提示显示正处在: <code>master</code>分支处，且没有任何文件。<br>创建第一个文件<code>READEME.md</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$touch READE.md</div><div class="line"></div><div class="line">$Git-tutorial ZH$ git status</div><div class="line">On branch master</div><div class="line"></div><div class="line">Initial commit</div><div class="line"></div><div class="line">Untracked files:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</div><div class="line"></div><div class="line">	READE.md</div><div class="line"></div><div class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</div></pre></td></tr></table></figure></p>
<p>可以在<code>Untracked files：</code>中看到这个文件，且并没有添加到暂存区</p>
<hr>
<h3 id="git-add-–-向暂存区添加文件"><a href="#git-add-–-向暂存区添加文件" class="headerlink" title="git add – 向暂存区添加文件"></a>git add – 向暂存区添加文件</h3><p>要想让文件成为Git仓库管理的对象，需要用<code>git add</code>命令添加到暂存区。暂存区是提交前的一个临时区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git add README.md </div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line"></div><div class="line">Initial commit</div><div class="line"></div><div class="line">Changes to be committed:</div><div class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</div><div class="line"></div><div class="line">	new file:   README.md</div></pre></td></tr></table></figure></p>
<p>可以看到<code>READEME.md</code>文件显示在<code>Changes to be committed</code>中了。</p>
<hr>
<h3 id="git-commit-–-保存仓库的历史记录"><a href="#git-commit-–-保存仓库的历史记录" class="headerlink" title="git commit – 保存仓库的历史记录"></a>git commit – 保存仓库的历史记录</h3><p><code>git commit</code>将当前暂存区中的文件实际保存到仓库的历史记录中。</p>
<ul>
<li>记叙一行提交信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;First Commit&quot;</div><div class="line">[master (root-commit) a6ce11d] First Commit</div><div class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</div><div class="line"> create mode 100644 README.md</div></pre></td></tr></table></figure>
</li>
</ul>
<p>-m参数后的“First Commit”成为提交信息，是对这个提交的描述。</p>
<ul>
<li>记叙详细提交信息</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
